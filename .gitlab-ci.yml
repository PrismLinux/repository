image: archlinux:latest

variables:
  REPO_NAME: "prismlinux"
  ARCH: "x86_64"
  REPO_DIR: "public"
  CACHE_DIR: "cache"
  CHECKSUMS_FILE: "package_checksums.txt"
  REMOTE_PACKAGES_FILE: "remote_packages.json"
  REBUILD_TRIGGER_FILE: "rebuild_packages.txt"
  PACKAGES_CONFIG: "packages.txt"
  STORAGE_DRIVER: "vfs"
  CONTAINER_NAME: "repo_builder_${CI_JOB_ID}"

before_script:
  # Update system and install dependencies
  - pacman -Syu --noconfirm
  - pacman -S --noconfirm crun podman python python-pip fuse-overlayfs

  # Configure Podman storage for CI environment
  - mkdir -p ~/.config/containers
  - |
    cat > ~/.config/containers/storage.conf << EOF
    [storage]
    driver = "vfs"
    graphroot = "/tmp/containers/storage"
    runroot = "/tmp/containers/storage"

    [storage.options]
    EOF

  # Configure containers.conf for CI compatibility - disable cgroup management
  - |
    cat > ~/.config/containers/containers.conf << EOF
    [containers]
    log_driver = "k8s-file"
    cgroup_manager = "disabled"
    events_logger = "file"

    [engine]
    cgroup_manager = "disabled"
    events_logger = "file"
    runtime = "crun"
    conmon_path = ["/usr/bin/conmon"]
    EOF

  # Create necessary directories
  - mkdir -p /tmp/containers/storage
  - mkdir -p ~/.local/share/containers
  - mkdir -p cache public

  # Test Podman configuration
  - podman info
  - podman version

  # Export environment variables for Podman
  - export STORAGE_DRIVER=vfs
  - export BUILDAH_ISOLATION=chroot

  # Clean up any existing containers
  - podman rm -f ${CONTAINER_NAME} || true
  - podman system prune -f || true

stages:
  - validate
  - check
  - build
  - deploy

validate_config:
  stage: validate
  script:
    - echo "Validating configuration..."
    - ls -la
    - test -f Dockerfile || (echo "Dockerfile not found!" && exit 1)
    - test -f packages.txt || (echo "packages.txt not found!" && exit 1)
    - test -d scripts || (echo "scripts directory not found!" && exit 1)

    # Build the container image
    - podman build -t repo_builder:latest .

    # Run the container directly with disabled cgroup management
    - |
      podman run --rm \
        --name ${CONTAINER_NAME} \
        --security-opt label=disable \
        --cgroup-manager disabled \
        --systemd=false \
        -v $(pwd)/cache:/app/cache \
        -v $(pwd)/public:/app/public \
        -v $(pwd)/scripts:/app/scripts \
        -v $(pwd)/packages.txt:/app/packages.txt \
        -v $(pwd)/website:/app/website \
        -e GITLAB_TOKEN=${GITLAB_TOKEN} \
        -e FORCE_REBUILD=${FORCE_REBUILD} \
        -e REPO_NAME=${REPO_NAME} \
        -e ARCH=${ARCH} \
        -e REPO_DIR=${REPO_DIR} \
        -e CACHE_DIR=${CACHE_DIR} \
        -e CHECKSUMS_FILE=${CHECKSUMS_FILE} \
        -e REMOTE_PACKAGES_FILE=${REMOTE_PACKAGES_FILE} \
        -e REBUILD_TRIGGER_FILE=${REBUILD_TRIGGER_FILE} \
        -e PACKAGES_CONFIG=${PACKAGES_CONFIG} \
        repo_builder:latest /app/scripts/run.sh

    - test -f public/rebuild_needed.txt && cat public/rebuild_needed.txt || echo "rebuild_needed.txt not found"
  artifacts:
    paths:
      - cache/
      - public/
      - remote_packages.json
      - rebuild_packages.txt
      - package_checksums.txt
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == 'schedule'
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_PIPELINE_SOURCE == 'web'
    - if: $FORCE_REBUILD == "true"

check_package_updates:
  stage: check
  needs:
    - job: validate_config
      artifacts: true
  script:
    - echo "Checking for package updates..."

    # Clean up any existing containers
    - podman rm -f ${CONTAINER_NAME} || true

    # Run the container directly
    - |
      podman run --rm \
        --name ${CONTAINER_NAME} \
        --security-opt label=disable \
        --cgroup-manager disabled \
        --systemd=false \
        -v $(pwd)/cache:/app/cache \
        -v $(pwd)/public:/app/public \
        -v $(pwd)/scripts:/app/scripts \
        -v $(pwd)/packages.txt:/app/packages.txt \
        -v $(pwd)/website:/app/website \
        -e GITLAB_TOKEN=${GITLAB_TOKEN} \
        -e FORCE_REBUILD=${FORCE_REBUILD} \
        -e REPO_NAME=${REPO_NAME} \
        -e ARCH=${ARCH} \
        -e REPO_DIR=${REPO_DIR} \
        -e CACHE_DIR=${CACHE_DIR} \
        -e CHECKSUMS_FILE=${CHECKSUMS_FILE} \
        -e REMOTE_PACKAGES_FILE=${REMOTE_PACKAGES_FILE} \
        -e REBUILD_TRIGGER_FILE=${REBUILD_TRIGGER_FILE} \
        -e PACKAGES_CONFIG=${PACKAGES_CONFIG} \
        repo_builder:latest /app/scripts/run.sh

    - test -f public/rebuild_needed.txt && cat public/rebuild_needed.txt || echo "rebuild_needed.txt not found"
  artifacts:
    paths:
      - cache/
      - public/
      - remote_packages.json
      - rebuild_packages.txt
      - package_checksums.txt
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == 'schedule'
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_PIPELINE_SOURCE == 'web'
    - if: $FORCE_REBUILD == "true"

build_repository:
  stage: build
  needs:
    - job: check_package_updates
      artifacts: true
  script:
    - echo "Building repository..."

    # Clean up any existing containers
    - podman rm -f ${CONTAINER_NAME} || true

    - |
      if [ -f public/rebuild_needed.txt ] && [ "$(cat public/rebuild_needed.txt)" = "true" ] || [ "$FORCE_REBUILD" = "true" ]; then
        echo "Rebuild needed, starting build process..."
        
        podman run --rm \
          --name ${CONTAINER_NAME} \
          --security-opt label=disable \
          --cgroup-manager disabled \
          --systemd=false \
          -v $(pwd)/cache:/app/cache \
          -v $(pwd)/public:/app/public \
          -v $(pwd)/scripts:/app/scripts \
          -v $(pwd)/packages.txt:/app/packages.txt \
          -v $(pwd)/website:/app/website \
          -e GITLAB_TOKEN=${GITLAB_TOKEN} \
          -e FORCE_REBUILD=${FORCE_REBUILD} \
          -e REPO_NAME=${REPO_NAME} \
          -e ARCH=${ARCH} \
          -e REPO_DIR=${REPO_DIR} \
          -e CACHE_DIR=${CACHE_DIR} \
          -e CHECKSUMS_FILE=${CHECKSUMS_FILE} \
          -e REMOTE_PACKAGES_FILE=${REMOTE_PACKAGES_FILE} \
          -e REBUILD_TRIGGER_FILE=${REBUILD_TRIGGER_FILE} \
          -e PACKAGES_CONFIG=${PACKAGES_CONFIG} \
          repo_builder:latest /app/scripts/run.sh
      else
        echo "No rebuild needed, skipping build stage."
        # Ensure public directory exists even if we skip build
        mkdir -p public
        echo "false" > public/rebuild_needed.txt
      fi
  artifacts:
    paths:
      - public/
      - cache/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == 'schedule'
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_PIPELINE_SOURCE == 'web'
    - if: $FORCE_REBUILD == "true"

pages:
  stage: deploy
  needs:
    - job: build_repository
      artifacts: true
  script:
    - echo "Deploying to GitLab Pages..."
    - ls -la public/
    - |
      if [ -d public ] && [ "$(ls -A public)" ]; then
        echo "Public directory contains files, proceeding with deployment"
        # For GitLab Pages, we need files in the root public directory
        # No need to copy to current directory as artifacts already specify public/
      else
        echo "Public directory is empty, creating index page"
        mkdir -p public
        echo "<h1>Repository is being built</h1>" > public/index.html
      fi
  artifacts:
    paths:
      - public
    expire_in: 1 month
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $FORCE_REBUILD == "true"
