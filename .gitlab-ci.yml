image: archlinux:base-devel

variables:
  REPO_NAME: "prismlinux"
  REPO_DIR: "public"
  CACHE_DIR: "cache"
  CHECKSUMS_FILE: "package_checksums.txt"
  REBUILD_TRIGGER_FILE: "rebuild_packages.txt"
  DYNAMIC_PIPELINE_FILE: "dynamic_pipeline.yml"
  CURL_TIMEOUT: "30"
  CURL_CONNECT_TIMEOUT: "10"

cache:
  key: "repo-cache-${CI_COMMIT_REF_SLUG}"
  paths:
    - "${CACHE_DIR}/"
    - "${CHECKSUMS_FILE}"
    - "${REBUILD_TRIGGER_FILE}"
    - "/var/cache/pacman/pkg/"
  policy: pull-push

stages:
  - prepare
  - check
  - build
  - test
  - deploy

.install_dependencies: &install_dependencies
  - pacman -Syu --noconfirm --needed curl jq base-devel git unzip

.error_handling: &error_handling
  - set -euo pipefail
  - |
    trap 'echo "Error at line $LINENO. Exit code: $?" >&2' ERR

.gitlab_api_config: &gitlab_api_config
  - |
    if [ -z "${GITLAB_TOKEN:-}" ]; then
      echo "ERROR: GITLAB_TOKEN is not set"
      exit 1
    fi
    export CURL_OPTS="--silent --show-error --fail --connect-timeout ${CURL_CONNECT_TIMEOUT} --max-time ${CURL_TIMEOUT}"

validate_config:
  stage: prepare
  before_script:
    - *install_dependencies
  script:
    - *error_handling
    - |
      if [ ! -f packages_id.txt ]; then
        echo "ERROR: packages_id.txt not found!"
        exit 1
      fi
      if ! grep -vE '^\s*#|^\s*$' packages_id.txt | tr -d '\r' | grep -qE '^[0-9]+'; then
        echo "ERROR: packages_id.txt contains invalid project IDs"
        exit 1
      fi
      echo "Configuration validation passed"

check_packages:
  stage: check
  needs: ["validate_config"]
  before_script:
    - *install_dependencies
    - *gitlab_api_config
  script:
    - *error_handling
    - mkdir -p "${CACHE_DIR}"
    - |
      declare -A old_checksums new_checksums remote_packages_map
      if [ -f "${CHECKSUMS_FILE}" ]; then
        while IFS='|' read -r filename checksum; do
          [ -n "$filename" ] && [ -n "$checksum" ] && old_checksums["$filename"]="$checksum"
        done < "${CHECKSUMS_FILE}"
      fi

      get_project_packages() {
        local project_id="$1"
        local releases_api_url="https://gitlab.com/api/v4/projects/${project_id}/releases"
        local latest_release
        latest_release=$(curl ${CURL_OPTS} --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$releases_api_url" | jq -r '.[0]? // empty')
        if [ -z "$latest_release" ] || [ "$latest_release" = "null" ]; then
          echo "WARNING: No releases found for project ${project_id}"
          return 1
        fi
        while IFS= read -r asset; do
          [ -z "$asset" ] && continue
          local asset_url asset_name
          asset_url=$(echo "$asset" | jq -r '.url // empty')
          asset_name=$(echo "$asset" | jq -r '.name // empty')
          if [[ "$asset_name" == *.pkg.tar.zst ]] && [ -n "$asset_url" ]; then
            remote_packages_map["${asset_name}"]="${asset_url}"
          fi
        done <<< "$(echo "$latest_release" | jq -c '.assets.links[]? // empty')"
      }

      download_and_check() {
        local pkg_filename="$1" download_url="$2" temp_file
        temp_file=$(mktemp)
        if curl --location ${CURL_OPTS} --header "PRIVATE-TOKEN: $GITLAB_TOKEN" --output "$temp_file" "$download_url"; then
          sha256sum "$temp_file" | awk '{print $1}'
          rm "$temp_file"
          return 0
        fi
        echo "ERROR: Failed to download ${pkg_filename}" >&2
        rm -f "$temp_file"
        return 1
      }

      project_ids=$(grep -vE '^\s*#|^\s*$' packages_id.txt | awk '{print $1}' | tr -d '\r')
      for project_id in $project_ids; do get_project_packages "$project_id" || continue; done

      changed_packages=()
      for pkg_filename in "${!remote_packages_map[@]}"; do
        download_url="${remote_packages_map[$pkg_filename]}"
        if checksum=$(download_and_check "$pkg_filename" "$download_url"); then
          new_checksums["$pkg_filename"]="$checksum"
          if [[ ! -v old_checksums["$pkg_filename"] ]] || [[ "${old_checksums[$pkg_filename]}" != "$checksum" ]]; then
            changed_packages+=("$pkg_filename")
            echo "CHANGED: $pkg_filename"
          fi
        fi
      done

      if [ ${#changed_packages[@]} -gt 0 ]; then
        printf '%s\n' "${changed_packages[@]}" > "${REBUILD_TRIGGER_FILE}"
        temp_checksums=$(mktemp)
        for pkg_filename in "${!new_checksums[@]}"; do
          echo "${pkg_filename}|${new_checksums[$pkg_filename]}" >> "$temp_checksums"
        done
        mv "$temp_checksums" "${CHECKSUMS_FILE}"
      else
        echo "No package changes detected."
      fi
  artifacts:
    paths:
      - "${REBUILD_TRIGGER_FILE}"
      - "${CHECKSUMS_FILE}"
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == 'schedule'
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

build_repository:
  stage: build
  needs: ["check_packages"]
  before_script:
    - *install_dependencies
    - *gitlab_api_config
  script:
    - *error_handling
    - |
      REPO_ARCH_DIR="${REPO_DIR}/x86_64"
      mkdir -p "${REPO_ARCH_DIR}"
      project_ids=$(grep -vE '^\s*#|^\s*$' packages_id.txt | awk '{print $1}' | tr -d '\r')
      package_count=0

      for project_id in $project_ids; do
        releases_api_url="https://gitlab.com/api/v4/projects/${project_id}/releases"
        latest_release=$(curl ${CURL_OPTS} --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$releases_api_url" | jq -r '.[0]? // empty')
        if [ -z "$latest_release" ] || [ "$latest_release" = "null" ]; then
          echo "WARNING: No releases found for project ${project_id}"
          continue
        fi
        echo "$latest_release" | jq -c '.assets.links[]? | select(.name | endswith(".pkg.tar.zst"))' | while read -r asset; do
          asset_url=$(echo "$asset" | jq -r '.url')
          asset_name=$(echo "$asset" | jq -r '.name')
          if [ -n "$asset_url" ] && [ -n "$asset_name" ]; then
            echo "Downloading ${asset_name}..."
            curl --location ${CURL_OPTS} --header "PRIVATE-TOKEN: $GITLAB_TOKEN" --output "${REPO_ARCH_DIR}/${asset_name}" "${asset_url}"
            ((package_count++))
          fi
        done
      done

      cd "${REPO_ARCH_DIR}"
      rm -f ${REPO_NAME}.db* ${REPO_NAME}.files*
      if [ $package_count -gt 0 ]; then
        repo-add "${REPO_NAME}.db.tar.gz" *.pkg.tar.zst
        ln -sf "${REPO_NAME}.db.tar.gz" "${REPO_NAME}.db"
        ln -sf "${REPO_NAME}.files.tar.gz" "${REPO_NAME}.files"
        echo "packages_found=true" > package_status.txt
      else
        tar -czf "${REPO_NAME}.db.tar.gz" -T /dev/null
        tar -czf "${REPO_NAME}.files.tar.gz" -T /dev/null
        ln -sf "${REPO_NAME}.db.tar.gz" "${REPO_NAME}.db"
        ln -sf "${REPO_NAME}.files.tar.gz" "${REPO_NAME}.files"
        echo "packages_found=false" > package_status.txt
      fi
  artifacts:
    paths:
      - "${REPO_DIR}/x86_64/"
      - package_status.txt
    expire_in: 1 day
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $REBUILD_TRIGGER_FILE
      exists:
        - "${REBUILD_TRIGGER_FILE}"

test_packages:
  stage: test
  needs: ["build_repository"]
  before_script:
    - *install_dependencies
  script:
    - *error_handling
    - |
      REPO_ARCH_DIR="${REPO_DIR}/x86_64"
      if [ ! -f "${REPO_ARCH_DIR}/${REPO_NAME}.db" ]; then
        echo "ERROR: Repository database not found!"
        exit 1
      fi
      for pkg_file in "${REPO_ARCH_DIR}"/*.pkg.tar.zst; do
        if [ -f "$pkg_file" ]; then
          echo "Validating: $(basename "$pkg_file")"
          pacman -Qip "$pkg_file" >/dev/null 2>&1 || { echo "ERROR: Invalid package: $(basename "$pkg_file")"; exit 1; }
        fi
      done
      echo "Repository validation passed."
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $REBUILD_TRIGGER_FILE
      exists:
        - "${REBUILD_TRIGGER_FILE}"

pages:
  stage: deploy
  needs: ["build_repository", "test_packages"]
  before_script:
    - *install_dependencies
    - curl -fsSL https://bun.sh/install | bash
    - export PATH="$HOME/.bun/bin:$PATH"
  script:
    - *error_handling
    - |
      if ! grep -q "packages_found=true" package_status.txt; then
        echo "No packages found, skipping pages deployment."
        exit 0
      fi
      REPO_ARCH_DIR="${REPO_DIR}/x86_64"
      mkdir -p "${REPO_DIR}/api"
      temp_json=$(mktemp)
      for pkg_file in "${REPO_ARCH_DIR}"/*.pkg.tar.zst; do
        [ -f "$pkg_file" ] || continue
        pkg_info=$(pacman -Qip "$pkg_file" 2>/dev/null || echo "")
        if [ -n "$pkg_info" ]; then
          name=$(echo "$pkg_info" | grep -m1 "^Name" | sed 's/Name[[:space:]]*:[[:space:]]*//')
          version=$(echo "$pkg_info" | grep -m1 "^Version" | sed 's/Version[[:space:]]*:[[:space:]]*//')
          desc=$(echo "$pkg_info" | grep -m1 "^Description" | sed 's/Description[[:space:]]*:[[:space:]]*//')
          arch=$(echo "$pkg_info" | grep -m1 "^Architecture" | sed 's/Architecture[[:space:]]*:[[:space:]]*//')
          filename=$(basename "$pkg_file")
          size=$(ls -lh "$pkg_file" | awk '{print $5}')
          modified=$(date -r "$pkg_file" '+%Y-%m-%d %H:%M:%S')
          jq -cn --arg name "$name" --arg version "$version" --arg desc "$desc" --arg arch "$arch" \
                 --arg filename "$filename" --arg size "$size" --arg modified "$modified" \
                 '{name: $name, version: $version, description: $desc, architecture: $arch, filename: $filename, size: $size, modified: $modified}' >> "$temp_json"
        fi
      done
      if [ -s "$temp_json" ]; then 
        jq -s . "$temp_json" > "${REPO_DIR}/api/packages.json"
      else 
        echo "[]" > "${REPO_DIR}/api/packages.json"
      fi
      rm -f "$temp_json"

      if [ -d "website" ]; then
        echo "Building Vue frontend..."
        cd website
        bun install --frozen-lockfile
        bun run build
        if [ ! -d "dist" ]; then
          echo "ERROR: Build failed - dist directory not found"
          exit 1
        fi
        echo "Copying dist contents to ${REPO_DIR}/..."
        cp -rv dist/* "${REPO_DIR}/"
        ls -la "${REPO_DIR}/" | head -20
      else
        echo "WARNING: website directory not found, skipping Vue build"
      fi
  artifacts:
    paths:
      - public
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $REBUILD_TRIGGER_FILE
      exists:
        - "${REBUILD_TRIGGER_FILE}"
