image: archlinux:base-devel

variables:
  REPO_NAME: "prismlinux"
  REPO_DIR: "public"
  DOWNLOAD_CACHE_DIR: "download_cache"
  CHECKSUMS_FILE: "package_checksums.txt"
  REBUILD_TRIGGER_FILE: "rebuild_packages.txt"
  DYNAMIC_PIPELINE_FILE: "dynamic_pipeline.yml"

cache:
  key: "repo-cache-${CI_COMMIT_REF_SLUG}"
  paths:
    - "${DOWNLOAD_CACHE_DIR}/"
    - "${CHECKSUMS_FILE}"
    - "/var/cache/pacman/pkg/"
  policy: pull-push

stages:
  - prepare
  - check
  - build
  - test
  - generate
  - deploy

.install_dependencies: &install_dependencies
  - pacman -Syu --noconfirm --needed curl jq base-devel git
  - pacman-key --init
  - pacman-key --populate archlinux

.error_handling: &error_handling
  - set -euo pipefail
  - |
    trap 'echo "Error at line $LINENO. Exit code: $?" >&2' ERR

validate_config:
  stage: prepare
  before_script:
    - *install_dependencies
  script:
    - *error_handling
    - |
      if [ ! -f packages_id.txt ]; then
        echo "ERROR: The file 'packages_id.txt' was not found!"
        exit 1
      fi
      if ! grep -vE '^\s*#|^\s*$' packages_id.txt | tr -d '\r' | grep -qE '^[0-9]+'; then
        echo "ERROR: 'packages_id.txt' contains invalid characters. Only project IDs are allowed."
        exit 1
      fi
      echo "Configuration validation passed."

check_packages:
  stage: check
  needs: ["validate_config"]
  before_script:
    - *install_dependencies
  script:
    - *error_handling
    - |
      if [ -z "${GITLAB_TOKEN:-}" ]; then
        echo "ERROR: GITLAB_TOKEN is not set. This token is required to read releases."
        exit 1
      fi

      CURL_OPTS="--silent --show-error --fail --location --connect-timeout 10 --max-time 30"

      mkdir -p "${DOWNLOAD_CACHE_DIR}"

      if [ -f "${CHECKSUMS_FILE}" ]; then
        declare -A old_checksums
        while IFS='|' read -r filename checksum; do
          [ -n "$filename" ] && [ -n "$checksum" ] && old_checksums["$filename"]="$checksum"
        done < "${CHECKSUMS_FILE}"
      fi

      project_ids=$(grep -vE '^\s*#|^\s*$' packages_id.txt | awk '{print $1}' | tr -d '\r')
      changed_packages=0

      for project_id in ${project_ids}; do
        releases_api_url="https://gitlab.com/api/v4/projects/${project_id}/releases"
        
        latest_release=$(curl ${CURL_OPTS} --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" "${releases_api_url}" | jq '.[0]? // empty')
        
        if [ -z "$latest_release" ] || [ "$latest_release" = "null" ]; then
          echo "WARNING: No releases found for project ${project_id}"
          continue
        fi
        
        echo "${latest_release}" | jq -c '.assets.links[]? | select(.name | endswith(".pkg.tar.zst"))' | while read -r asset; do
          asset_name=$(echo "$asset" | jq -r '.name')
          asset_url=$(echo "$asset" | jq -r '.url')
          temp_file=$(mktemp)
          
          echo "Checking: ${asset_name}"
          curl ${CURL_OPTS} --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" --output "${temp_file}" "${asset_url}"
          new_checksum=$(sha256sum "${temp_file}" | awk '{print $1}')
          
          if [[ ! -v old_checksums["$asset_name"] ]] || [[ "${old_checksums[$asset_name]}" != "$new_checksum" ]]; then
            echo "CHANGED: ${asset_name}"
            mv "${temp_file}" "${DOWNLOAD_CACHE_DIR}/${asset_name}"
            changed_packages=1
          else
            rm -f "${temp_file}"
          fi
          
          echo "${asset_name}|${new_checksum}" >> "${CHECKSUMS_FILE}.tmp"
        done
      done

      # Перевіряємо, чи існує тимчасовий файл, перш ніж його переміщувати
      if [ -f "${CHECKSUMS_FILE}.tmp" ]; then
        mv "${CHECKSUMS_FILE}.tmp" "${CHECKSUMS_FILE}"
      fi

      if [ "$changed_packages" -eq 1 ]; then
        echo "Package changes detected. Triggering rebuild."
        touch "${REBUILD_TRIGGER_FILE}"
      else
        echo "No package changes detected."
        rm -f "${REBUILD_TRIGGER_FILE}"
      fi
  artifacts:
    paths:
      - "${REBUILD_TRIGGER_FILE}"
      - "${CHECKSUMS_FILE}"
    expire_in: 1 hour

build_repository:
  stage: build
  needs: ["check_packages"]
  before_script:
    - *install_dependencies
  script:
    - *error_handling
    - |
      REPO_ARCH_DIR="${REPO_DIR}/x86_64"
      mkdir -p "${REPO_ARCH_DIR}"

      if [ -d "${DOWNLOAD_CACHE_DIR}" ] && [ "$(ls -A ${DOWNLOAD_CACHE_DIR})" ]; then
        echo "Copying packages from cache..."
        cp -v "${DOWNLOAD_CACHE_DIR}"/*.pkg.tar.zst "${REPO_ARCH_DIR}/"
      fi

      cd "${REPO_ARCH_DIR}"

      if ! ls *.pkg.tar.zst 1> /dev/null 2>&1; then
        echo "No packages found to build the repository."
        echo "packages_found=false" > ../../package_status.txt
      else
        echo "Building repository database..."
        rm -f "${REPO_NAME}".db* "${REPO_NAME}".files*
        repo-add --nocolor "${REPO_NAME}.db.tar.gz" *.pkg.tar.zst
        ln -sf "${REPO_NAME}.db.tar.gz" "${REPO_NAME}.db"
        ln -sf "${REPO_NAME}.files.tar.gz" "${REPO_NAME}.files"
        echo "packages_found=true" > ../../package_status.txt
      fi
  artifacts:
    paths:
      - "${REPO_DIR}/"
      - package_status.txt
    expire_in: 1 day
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $REBUILD_TRIGGER_FILE
      exists:
        - "${REBUILD_TRIGGER_FILE}"

test_packages:
  stage: test
  needs: ["build_repository"]
  before_script:
    - *install_dependencies
  script:
    - *error_handling
    - |
      REPO_ARCH_DIR="${REPO_DIR}/x86_64"

      if ! grep -q "packages_found=true" package_status.txt; then
        echo "No new packages were built. Skipping tests."
        exit 0
      fi

      if [ ! -f "${REPO_ARCH_DIR}/${REPO_NAME}.db" ]; then
        echo "ERROR: Repository database not found!"
        exit 1
      fi

      echo "Validating packages in repository..."
      for pkg_file in "${REPO_ARCH_DIR}"/*.pkg.tar.zst; do
        echo "Validating: $(basename "$pkg_file")"
        pacman -Qip "$pkg_file" >/dev/null || { echo "ERROR: Invalid package: $(basename "$pkg_file")"; exit 1; }
      done
      echo "Repository validation passed."
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $REBUILD_TRIGGER_FILE
      exists:
        - "${REBUILD_TRIGGER_FILE}"

generate_dynamic_pipeline:
  stage: generate
  needs: ["test_packages"]
  script:
    - *error_handling
    - |
      if grep -q "packages_found=true" package_status.txt; then
        echo "Generating dynamic pipeline for GitLab Pages deployment..."
        cat > "${DYNAMIC_PIPELINE_FILE}" << 'EOF'
        pages:
          stage: deploy
          image: archlinux:base-devel
          script:
            - set -euo pipefail
            - trap 'echo "Error at line $LINENO. Exit code: $?" >&2' ERR
            - |
              API_DIR="public/api"
              mkdir -p "${API_DIR}"
              temp_json_objects=$(mktemp)
              echo "Generating packages.json for API..."
              for pkg_file in public/x86_64/*.pkg.tar.zst; do
                [ -f "$pkg_file" ] || continue
                pkg_info=$(pacman -Qip "$pkg_file" 2>/dev/null)
                if [ -n "$pkg_info" ]; then
                  jq -n \
                    --arg name "$(echo "$pkg_info" | grep -oP '^Name\s+:\s+\K.*')" \
                    --arg version "$(echo "$pkg_info" | grep -oP '^Version\s+:\s+\K.*')" \
                    --arg desc "$(echo "$pkg_info" | grep -oP '^Description\s+:\s+\K.*')" \
                    --arg arch "$(echo "$pkg_info" | grep -oP '^Architecture\s+:\s+\K.*')" \
                    --arg size "$(echo "$pkg_info" | grep -oP '^Installed Size\s+:\s+\K.*')" \
                    --arg file "$(basename "$pkg_file")" \
                    '{name: $name, version: $version, description: $desc, architecture: $arch, installed_size: $size, filename: $file}' >> "$temp_json_objects"
                fi
              done
              jq -s . "$temp_json_objects" > "${API_DIR}/packages.json"
              rm "$temp_json_objects"
              echo "API file 'packages.json' created successfully."
          artifacts:
            paths:
              - public
          rules:
            - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      EOF
      else
        echo "No packages found, skipping dynamic pipeline generation."
        touch "${DYNAMIC_PIPELINE_FILE}"
      fi
  artifacts:
    paths:
      - "${DYNAMIC_PIPELINE_FILE}"

trigger_pages_deploy:
  stage: deploy
  trigger:
    include:
      - artifact: "dynamic_pipeline.yml"
        job: generate_dynamic_pipeline
    strategy: depend
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      exists:
        - "${REBUILD_TRIGGER_FILE}"
