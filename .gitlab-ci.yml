image: archlinux:latest

variables:
  REPO_NAME: "prismlinux"
  ARCH: "x86_64"
  REPO_DIR: "public"
  CACHE_DIR: "cache"
  # Let the script inside the container handle these paths
  CONTAINER_IMAGE: "repo_builder:latest"
  CONTAINER_NAME: "repo_builder_${CI_JOB_ID}"
  STORAGE_DRIVER: "vfs" # For Podman configuration

stages:
  - build_image
  - build_repo
  - deploy

before_script:
  # Update system and install dependencies
  - pacman -Syu --noconfirm
  - pacman -S --noconfirm crun podman python python-pip fuse-overlayfs

  # Configure Podman storage for CI environment
  - mkdir -p ~/.config/containers
  - |
    cat > ~/.config/containers/storage.conf << EOF
    [storage]
    driver = "${STORAGE_DRIVER}"
    graphroot = "/tmp/containers/storage"
    runroot = "/tmp/containers/storage"
    [storage.options]
    EOF

  # Configure containers.conf for CI compatibility
  - |
    cat > ~/.config/containers/containers.conf << EOF
    [engine]
    cgroup_manager = "cgroupfs" # <-- CORRECTED
    events_logger = "file"
    runtime = "crun"
    EOF

  # Create necessary directories
  - mkdir -p /tmp/containers/storage cache public

  # Test Podman configuration
  - podman info

build_container_image:
  stage: build_image
  script:
    - echo "Building container image..."
    - test -f Dockerfile || (echo "Dockerfile not found!" && exit 1)
    - podman build -t ${CONTAINER_IMAGE} .
  # No artifacts needed, the image is stored locally on the runner for subsequent stages

build_repository:
  stage: build_repo
  needs:
    - build_container_image
  script:
    - echo "Running repository build script..."
    # Clean up any previous container instance, just in case
    - podman rm -f ${CONTAINER_NAME} || true

    # This single run handles checking for updates AND building the repo if needed.
    - |
      podman run --rm \
        --name ${CONTAINER_NAME} \
        --cgroup-manager cgroupfs \ # <-- CORRECTED
        --security-opt label=disable \
        --systemd=false \
        -v "$(pwd)/cache:/app/cache" \
        -v "$(pwd)/public:/app/public" \
        -v "$(pwd)/scripts:/app/scripts" \
        -v "$(pwd)/packages.txt:/app/packages.txt" \
        -v "$(pwd)/website:/app/website" \
        -e GITLAB_TOKEN \
        -e FORCE_REBUILD \
        -e REPO_NAME \
        -e ARCH \
        ${CONTAINER_IMAGE} /app/scripts/run.sh

    - echo "Script execution finished. Listing public directory:"
    - ls -la public/
  artifacts:
    paths:
      - public/
      - cache/ # Cache can be useful for subsequent runs on the same branch
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == 'schedule'
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_PIPELINE_SOURCE == 'web'
    - if: $FORCE_REBUILD == "true"

pages:
  stage: deploy
  needs:
    - job: build_repository
      artifacts: true
  script:
    - echo "Deploying to GitLab Pages..."
    - |
      if [ ! -d public ] || [ -z "$(ls -A public)" ]; then
        echo "Public directory is empty. Creating a placeholder index.html."
        mkdir -p public
        echo "<h1>Repository deployment in progress.</h1>" > public/index.html
      else
        echo "Public directory contains files. Deployment will proceed."
      fi
    - ls -la public
  artifacts:
    paths:
      - public
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
