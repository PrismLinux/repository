# Use a base image with the necessary tools
image: archlinux:latest

stages:
  - build_image
  - build_repo
  - deploy

variables:
  CONTAINER_IMAGE_TAG: ${CI_REGISTRY_IMAGE}/repository:latest

  REPO_NAME: "prismlinux"
  ARCH: "x86_64"
  REPO_DIR: "public"
  CACHE_DIR: "cache"
  CONTAINER_NAME: "repo_builder_${CI_JOB_ID}"
  STORAGE_DRIVER: "vfs"

before_script:
  # Update system and install dependencies for running Podman
  - pacman -Syu --noconfirm
  - pacman -S --noconfirm crun podman python python-pip fuse-overlayfs

  # Configure Podman storage for the CI environment
  - mkdir -p ~/.config/containers
  - |
    cat > ~/.config/containers/storage.conf << EOF
    [storage]
    driver = "${STORAGE_DRIVER}"
    graphroot = "/tmp/containers/storage"
    runroot = "/tmp/containers/storage"
    [storage.options]
    EOF

  # Configure containers.conf for CI compatibility, using 'cgroupfs'
  - |
    cat > ~/.config/containers/containers.conf << EOF
    [engine]
    cgroup_manager = "cgroupfs"
    events_logger = "file"
    runtime = "crun"
    EOF

  # Create necessary directories
  - mkdir -p /tmp/containers/storage cache public

  # Verify Podman is working
  - podman info

build_container_image:
  stage: build_image
  script:
    - echo "Logging in to GitLab Container Registry..."
    - podman login -u "${CI_REGISTRY_USER}" -p "${CI_JOB_TOKEN}" ${CI_REGISTRY}

    - echo "Building and pushing container image to ${CONTAINER_IMAGE_TAG}..."
    - podman build -t ${CONTAINER_IMAGE_TAG} .
    - podman push ${CONTAINER_IMAGE_TAG}

build_repository:
  stage: build_repo
  needs:
    - build_container_image # This job depends on the image being built
  script:
    - echo "Logging in to GitLab Container Registry..."
    # Log in again to be able to pull the image from the registry
    - podman login -u "${CI_REGISTRY_USER}" -p "${CI_JOB_TOKEN}" ${CI_REGISTRY}

    - echo "Running repository build script using image from registry..."
    - podman rm -f ${CONTAINER_NAME} || true
    - |
      podman run --rm \
        --name ${CONTAINER_NAME} \
        --cgroup-manager cgroupfs \
        --security-opt label=disable \
        --systemd=false \
        -v "$(pwd)/cache:/app/cache" \
        -v "$(pwd)/public:/app/public" \
        -v "$(pwd)/scripts:/app/scripts" \
        -v "$(pwd)/packages.txt:/app/packages.txt" \
        -v "$(pwd)/website:/app/website" \
        -e GITLAB_TOKEN \
        -e FORCE_REBUILD \
        -e REPO_NAME \
        -e ARCH \
        ${CONTAINER_IMAGE_TAG} /app/scripts/run.sh

    - echo "Script execution finished. Listing public directory:"
    - ls -la public/
  artifacts:
    paths:
      - public/
      - cache/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == 'schedule'
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_PIPELINE_SOURCE == 'web'
    - if: $FORCE_REBUILD == "true"

pages:
  stage: deploy
  needs:
    - job: build_repository
      artifacts: true
  script:
    - echo "Deploying to GitLab Pages..."
    - |
      if [ ! -d public ] || [ -z "$(ls -A public)" ]; then
        echo "Public directory is empty. Creating a placeholder index.html."
        mkdir -p public
        echo "<h1>Repository deployment in progress.</h1>" > public/index.html
      else
        echo "Public directory contains files. Deployment will proceed."
      fi
    - echo "Contents of public directory:"
    - ls -la public
  artifacts:
    paths:
      - public
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
