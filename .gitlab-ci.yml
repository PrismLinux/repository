# Copyright (C) 2025 CrystalNetwork Studio
#
# This file is part of the CrystalNetwork Studio, PrismLinux Repository.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

image: "archlinux:latest"

variables:
  REPO_NAME: "prismlinux"
  REPO_BRANCH: "repo"
  REPO_DIR: "public"
  PKGBUILD_DIR: "PKGBUILDs"

stages:
  - "detect_and_build"
  - "update_repo"
  - "deploy"

# Detect changed packages and build them all in one job
build_changed_packages:
  stage: "detect_and_build"
  before_script:
    - "pacman -Syu --noconfirm devtools git base-devel"
  script:
    - |
      # Determine which package directories with PKGBUILD have changed
      CHANGED_DIRS=$(git diff --name-only $CI_COMMIT_BEFORE_SHA $CI_COMMIT_SHA | grep "${PKGBUILD_DIR}/.*/PKGBUILD$" | xargs -n1 dirname | sed "s|^${PKGBUILD_DIR}/||" | sort -u)

      echo "Found changed packages: $CHANGED_DIRS"

      if [ -z "$CHANGED_DIRS" ]; then
        echo "No package changes detected"
        exit 0
      fi

      # Create directory for built packages
      mkdir -p built_packages

      # Build each changed package
      for pkg_dir in $CHANGED_DIRS; do
        echo "Building package: $pkg_dir"
        cd ${PKGBUILD_DIR}/$pkg_dir
        makepkg --printsrcinfo > .SRCINFO
        extra-x86_64-build -- -s
        cd ../../
        cp ${PKGBUILD_DIR}/$pkg_dir/*.pkg.tar.zst built_packages/
      done
  artifacts:
    paths:
      - "built_packages/*.pkg.tar.zst"
  rules:
    - if: "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"

# Update repository with local and remote packages
update_repository:
  stage: "update_repo"
  before_script:
    - "pacman -Syu --noconfirm pacman curl jq"
    - 'git config user.email "ci@gitlab"'
    - 'git config user.name "GitLab CI"'
  script:
    - |
      # Clone or initialize repo branch
      if ! git ls-remote --exit-code . "refs/heads/$REPO_BRANCH" >/dev/null; then
        git checkout --orphan $REPO_BRANCH
        git rm -rf .
        echo "PrismLinux repository" > README.md
        git add README.md
        git commit -m "Initial repository"
        git push -u origin $REPO_BRANCH
        git checkout $CI_DEFAULT_BRANCH
      fi

      # Clone the repo branch
      git clone -b $REPO_BRANCH "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git" repo-branch
      cd repo-branch

      # Create a temporary directory for processing
      mkdir -p ../temp_processing
      cd ../temp_processing

      # Copy locally built packages if available
      if [ -d "../built_packages" ]; then
        echo "Copying locally built packages"
        cp ../built_packages/*.pkg.tar.zst . || true
      fi

      # --- Process remote HTTPS packages ---
      declare -A remote_packages_map
      if [ -f "../${PKGBUILD_DIR}/remote_packages.txt" ]; then
        echo "Reading remote package URLs from remote_packages.txt..."
        while IFS= read -r url; do
          # Skip empty lines and comments
          [[ -z "$url" || "$url" =~ ^[[:space:]]*# ]] && continue
          # Basic check if it looks like a URL ending in .pkg.tar.zst
          if [[ "$url" =~ \.pkg\.tar\.zst(\?[^[:space:]]*)?$ ]]; then
            filename=$(basename "$url" | cut -d'?' -f1)
            if [[ -n "$filename" ]]; then
              echo "  -> Adding remote package: $filename from $url"
              remote_packages_map["$filename"]="$url"
            fi
          fi
        done < "../${PKGBUILD_DIR}/remote_packages.txt"
      fi

      # --- Process GitLab project packages ---
      if [ -f "../${PKGBUILD_DIR}/packages_id.txt" ]; then
        echo "Reading project IDs from packages_id.txt..."
        while IFS= read -r project_id; do
          # Skip empty lines and comments
          [[ -z "$project_id" || "$project_id" =~ ^[[:space:]]*# ]] && continue

          echo "Fetching latest release from project ${project_id}..."
          RELEASES_API_URL="https://gitlab.com/api/v4/projects/${project_id}/releases"
          LATEST_RELEASE=$(curl --silent --show-error --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$RELEASES_API_URL" | jq -r '.[0]')

          if [ "$LATEST_RELEASE" = "null" ]; then
            echo "WARNING: No releases found for project ${project_id}. Skipping."
            continue
          fi

          # Process all assets in the release
          echo "$LATEST_RELEASE" | jq -c '.assets.links[]?' | while read -r asset; do
            if [ -z "$asset" ] || [ "$asset" = "null" ]; then continue; fi

            ASSET_URL=$(echo "$asset" | jq -r '.url')
            ASSET_NAME=$(echo "$asset" | jq -r '.name')

            # Check if the asset is a package file
            if [[ "$ASSET_NAME" == *.pkg.tar.zst ]]; then
              echo "  -> Adding GitLab package: ${ASSET_NAME} from ${ASSET_URL}"
              remote_packages_map["${ASSET_NAME}"]="${ASSET_URL}"
            fi
          done
        done < "../${PKGBUILD_DIR}/packages_id.txt"
      fi

      # Download remote packages
      echo "Downloading remote packages..."
      for pkg_filename in "${!remote_packages_map[@]}"; do
        if [ ! -f "$pkg_filename" ]; then
          echo "  -> Downloading: $pkg_filename"
          DOWNLOAD_URL="${remote_packages_map[$pkg_filename]}"
          if ! curl --location --silent --show-error --fail --output "$pkg_filename" "${DOWNLOAD_URL}"; then
            echo "    ERROR: Failed to download $pkg_filename from $DOWNLOAD_URL"
            rm -f "$pkg_filename"
          fi
        fi
      done

      # Clean up orphaned packages (packages that are no longer referenced)
      echo "Checking for orphaned packages in repository..."
      cd repo-branch
      for local_pkg_path in *.pkg.tar.zst; do
        [ -f "$local_pkg_path" ] || continue
        local_pkg_filename=$(basename "$local_pkg_path")

        # Check if this package is still referenced (either locally built or in remote lists)
        package_exists=false

        # Check if it's in locally built packages
        if [ -f "../temp_processing/$local_pkg_filename" ]; then
          package_exists=true
        else
          # Check if it's in remote packages map
          while read -r url; do
            [[ -z "$url" || "$url" =~ ^[[:space:]]*# ]] && continue
            if [[ "$url" =~ \.pkg\.tar\.zst(\?[^[:space:]]*)?$ ]]; then
              filename=$(basename "$url" | cut -d'?' -f1)
              if [ "$filename" = "$local_pkg_filename" ]; then
                package_exists=true
                break
              fi
            fi
          done < "../${PKGBUILD_DIR}/remote_packages.txt" 2>/dev/null || true

          # Check if it's from GitLab projects
          if [ ! "$package_exists" = true ] && [ -f "../${PKGBUILD_DIR}/packages_id.txt" ]; then
            while IFS= read -r project_id; do
              [[ -z "$project_id" || "$project_id" =~ ^[[:space:]]*# ]] && continue

              RELEASES_API_URL="https://gitlab.com/api/v4/projects/${project_id}/releases"
              LATEST_RELEASE=$(curl --silent --show-error --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$RELEASES_API_URL" | jq -r '.[0]')

              if [ "$LATEST_RELEASE" != "null" ]; then
                echo "$LATEST_RELEASE" | jq -c '.assets.links[]?' | while read -r asset; do
                  if [ -z "$asset" ] || [ "$asset" = "null" ]; then continue; fi

                  ASSET_NAME=$(echo "$asset" | jq -r '.name')
                  if [ "$ASSET_NAME" = "$local_pkg_filename" ]; then
                    package_exists=true
                    break 2
                  fi
                done
              fi
            done < "../${PKGBUILD_DIR}/packages_id.txt" 2>/dev/null || true
          fi
        fi

        # Remove orphaned package
        if [ "$package_exists" = false ]; then
          echo "  -> Removing orphaned package: $local_pkg_filename"
          rm -f "$local_pkg_path"
        fi
      done

      # Copy new packages to repository
      cd ..
      if [ -n "$(ls -A temp_processing/*.pkg.tar.zst 2>/dev/null)" ]; then
        echo "Copying new packages to repository"
        cp temp_processing/*.pkg.tar.zst repo-branch/
      fi

      # Update repository database
      cd repo-branch
      echo "Updating repository database..."

      # Remove old database files
      rm -f ${REPO_NAME}.db ${REPO_NAME}.db.tar.gz ${REPO_NAME}.files ${REPO_NAME}.files.tar.gz

      # Create new database
      if [ -n "$(ls -A *.pkg.tar.zst 2>/dev/null)" ]; then
        repo-add ${REPO_NAME}.db.tar.gz *.pkg.tar.zst
      else
        echo "No packages found in repository. The database will be empty."
        touch "${REPO_NAME}.db.tar.gz" "${REPO_NAME}.files.tar.gz"
      fi

      # Create symlinks for compatibility
      ln -sf ${REPO_NAME}.db.tar.gz ${REPO_NAME}.db
      ln -sf ${REPO_NAME}.files.tar.gz ${REPO_NAME}.files

      # Prepare commit
      git add .
      git commit -m "Updated repository [skip ci]" || exit 0
      git push origin $REPO_BRANCH
  dependencies:
    - "build_changed_packages"
  rules:
    - if: "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"

# Deploy web interface
deploy_web_interface:
  stage: "deploy"
  before_script:
    - "pacman -Syu --noconfirm curl base-devel"
    # Install Bun
    - "curl -fsSL https://bun.sh/install | bash"
    - 'export PATH="$HOME/.bun/bin:$PATH"'
  script:
    - |
      # Create structure for GitLab Pages
      mkdir -p public/api

      # Clone the repo branch to get package information
      git clone -b $REPO_BRANCH "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git" repo-branch

      # Generate JSON with package information
      echo "Generating packages.json..."
      generate_package_json() {
        cd repo-branch
        for pkg in *.pkg.tar.zst; do
          [ -f "$pkg" ] || continue
          pkg_info=$(pacman -Qip "$pkg" 2>/dev/null)

          jq -cn \
            --arg name "$(echo "$pkg_info" | grep -m1 "^Name" | sed 's/Name\s*:\s*//')" \
            --arg version "$(echo "$pkg_info" | grep -m1 "^Version" | sed 's/Version\s*:\s*//')" \
            --arg desc "$(echo "$pkg_info" | grep -m1 "^Description" | sed 's/Description\s*:\s*//')" \
            --arg arch "$(echo "$pkg_info" | grep -m1 "^Architecture" | sed 's/Architecture\s*:\s*//')" \
            --arg filename "$pkg" \
            --arg size "$(ls -lh "$pkg" | awk '{print $5}')" \
            --arg modified "$(date -r "$pkg" '+%Y-%m-%d %H:%M:%S')" \
            '{name: $name, version: $version, description: $desc, architecture: $arch, filename: $filename, size: $size, modified: $modified}'
        done
      }

      generate_package_json | jq -s . > public/api/packages.json

      # Build Vue application
      echo "Building Vue application..."
      cd website
      bun install --frozen-lockfile
      bun run build
      cp -r dist/* ../public/

      # Add repository information to index.html
      sed -i "s|REPO_SERVER|https://$CI_PROJECT_ROOT_NAMESPACE.gitlab.io/$CI_PROJECT_NAME|" public/index.html
  dependencies:
    - "update_repository"
  artifacts:
    paths:
      - "public"
  rules:
    - if: "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
