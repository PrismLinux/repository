# Copyright (C) 2025 CrystalNetwork Studio
#
# This file is part of the CrystalNetwork Studio, PrismLinux Repository.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

image: archlinux:latest

variables:
  REPO_NAME: "prismlinux"
  REPO_DIR: "public"

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == 'schedule'
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == 'push'
    - if: ($CI_PIPELINE_SOURCE == 'push' || $CI_PIPELINE_SOURCE == 'merge_request_event')
      changes:
        - website/**/*
        - .gitlab-ci.yml
        - packages_id.txt

cache:
  key: "repo-cache-${CI_COMMIT_REF_SLUG}"
  paths:
    - "${REPO_DIR}/x86_64/"
  policy: pull-push

pages:
  stage: deploy
  pages: true

  before_script:
    - pacman -Syu --noconfirm
    - pacman -S --noconfirm curl jq base-devel git unzip
    # Install Bun
    - curl -fsSL https://bun.sh/install | bash
    # Add Bun to PATH for the current script execution
    - export PATH="$HOME/.bun/bin:$PATH"

  script: |
    set -eo pipefail
    REPO_ARCH_DIR="${REPO_DIR}/x86_64"

    echo "Ensuring required directories exist..."
    mkdir -p "${REPO_ARCH_DIR}"
    # This directory will hold packages.json, which is needed by the Vue app
    mkdir -p "${REPO_DIR}/api"

    echo "Cleaning up existing Vue app files in public/ (index.html, assets/)..."
    # Remove files and directories generated by previous Vue builds to ensure a clean deployment.
    # This specifically targets index.html and the assets directory, leaving other content intact.
    rm -f "${REPO_DIR}/index.html" || true
    rm -rf "${REPO_DIR}/assets" || true

    declare -A remote_packages_map
    echo "Fetching list of all available remote packages from releases..."

    # Read project IDs from the file, ignore comments and empty lines
    if [ ! -f packages_id.txt ]; then
      echo "ERROR: packages_id.txt not found!"
      exit 1
    fi

    PROJECT_IDS_TO_PROCESS=$(grep -vE '^\s*#|^\s*$' packages_id.txt | awk '{print $1}' | tr '\n' ' ')
    echo "Processing Project IDs: ${PROJECT_IDS_TO_PROCESS}"

    for project_id in $PROJECT_IDS_TO_PROCESS; do
      RELEASES_API_URL="https://gitlab.com/api/v4/projects/${project_id}/releases"
      LATEST_RELEASE=$(curl --silent --show-error --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$RELEASES_API_URL" | jq -r '.[0]')

      if [ "$LATEST_RELEASE" = "null" ]; then
        echo "WARNING: No releases found for project ${project_id}. Skipping."
        continue
      fi

      while IFS= read -r asset; do
        if [ -z "$asset" ]; then continue; fi
        ASSET_URL=$(echo "$asset" | jq -r '.url')
        ASSET_NAME=$(echo "$asset" | jq -r '.name')

        if [[ "$ASSET_NAME" == *.pkg.tar.zst ]]; then
          remote_packages_map["${ASSET_NAME}"]="${ASSET_URL}"
        fi
      done <<< "$(echo "$LATEST_RELEASE" | jq -c '.assets.links[]?')"
    done

    echo "Checking for orphaned packages in local repository..."
    for local_pkg_path in "${REPO_ARCH_DIR}"/*.pkg.tar.zst; do
      [ -f "$local_pkg_path" ] || continue
      local_pkg_filename=$(basename "$local_pkg_path")
      if [[ ! -v remote_packages_map["${local_pkg_filename}"] ]]; then
        echo "  -> Removing orphaned package: ${local_pkg_filename}"
        rm "$local_pkg_path"
      fi
    done

    echo "Checking for new packages to download..."
    for pkg_filename in "${!remote_packages_map[@]}"; do
      if [ ! -f "${REPO_ARCH_DIR}/${pkg_filename}" ]; then
        echo "  -> Downloading new package: ${pkg_filename}"
        DOWNLOAD_URL="${remote_packages_map[$pkg_filename]}"
        if ! curl --location --silent --show-error --fail --header "PRIVATE-TOKEN: $GITLAB_TOKEN" --output "${REPO_ARCH_DIR}/${pkg_filename}" "${DOWNLOAD_URL}"; then
          echo "    ERROR: Failed to download ${pkg_filename} from ${DOWNLOAD_URL}"
          rm -f "${REPO_ARCH_DIR}/${pkg_filename}"
        fi
      fi
    done

    echo "Updating repository database..."
    (
      cd "${REPO_ARCH_DIR}"

      rm -f ${REPO_NAME}.db ${REPO_NAME}.db.tar.gz ${REPO_NAME}.files ${REPO_NAME}.files.tar.gz

      if ls ./*.pkg.tar.zst 1> /dev/null 2>&1; then
        echo "Found packages. Rebuilding repository database..."
        repo-add "${REPO_NAME}.db.tar.gz" *.pkg.tar.zst
      else
        echo "No packages found in repository. The database will be empty."
        touch "${REPO_NAME}.db.tar.gz" "${REPO_NAME}.files.tar.gz"
      fi

      echo "Ensuring database files are compatible with static hosting..."
      ln -sf "${REPO_NAME}.db.tar.gz" "${REPO_NAME}.db"
      ln -sf "${REPO_NAME}.files.tar.gz" "${REPO_NAME}.files"
    )

    echo "Generating package metadata for web interface (packages.json)..."
    generate_json_objects() {
      for pkg_file in "${REPO_ARCH_DIR}"/*.pkg.tar.zst; do
        [ -f "$pkg_file" ] || continue
        pkg_info=$(pacman -Qip "$pkg_file" 2>/dev/null)

        jq -cn \
          --arg name "$(echo "$pkg_info" | grep -m1 "^Name" | sed 's/Name\s*:\s*//')" \
          --arg version "$(echo "$pkg_info" | grep -m1 "^Version" | sed 's/Version\s*:\s*//')" \
          --arg desc "$(echo "$pkg_info" | grep -m1 "^Description" | sed 's/Description\s*:\s*//')" \
          --arg arch "$(echo "$pkg_info" | grep -m1 "^Architecture" | sed 's/Architecture\s*:\s*//')" \
          --arg filename "$(basename "$pkg_file")" \
          --arg size "$(ls -lh "$pkg_file" | awk '{print $5}')" \
          --arg modified "$(date -r "$pkg_file" '+%Y-%m-%d %H:%M:%S')" \
          --arg depends "$(echo "$pkg_info" | grep -m1 "^Depends On" | sed 's/Depends On\s*:\s*//' || echo 'None')" \
          --arg groups "$(echo "$pkg_info" | grep -m1 "^Groups" | sed 's/Groups\s*:\s*//' || echo 'None')" \
          '{name: $name, version: $version, description: $desc, architecture: $arch, filename: $filename, size: $size, modified: $modified, depends: $depends, groups: $groups}'
      done
    }
    generate_json_objects | jq -s . > "${REPO_DIR}/api/packages.json"

    echo "Building Vue frontend with Bun..."
    (
      cd website
      bun install --frozen-lockfile
      bun run build
    )

    echo "Copying built Vue app from website/dist to public directory..."
    cp -r website/dist/. "${REPO_DIR}/"

    echo "-----------------------------------------"
    echo "Final check before artifact upload:"
    ls -laR public
    echo "-----------------------------------------"

  artifacts:
    paths:
      - public
